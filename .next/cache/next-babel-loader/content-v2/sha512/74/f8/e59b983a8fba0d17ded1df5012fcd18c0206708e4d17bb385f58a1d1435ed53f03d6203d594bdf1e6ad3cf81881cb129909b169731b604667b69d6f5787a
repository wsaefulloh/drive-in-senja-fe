{"ast":null,"code":"import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* eslint-disable */\nimport React from \"react\";\n\nfunction uniq(arr) {\n  let out = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    if (out.indexOf(arr[i]) === -1) {\n      out.push(arr[i]);\n    }\n  }\n\n  return out;\n}\n/* istanbul ignore next */\n\n\nfunction getClipboardData(e) {\n  if (window.clipboardData) {\n    return window.clipboardData.getData(\"Text\");\n  }\n\n  if (e.clipboardData) {\n    return e.clipboardData.getData(\"text/plain\");\n  }\n\n  return \"\";\n}\n\nfunction defaultRenderTag(props) {\n  let {\n    tag,\n    key,\n    disabled,\n    onRemove,\n    classNameRemove,\n    getTagDisplayValue\n  } = props,\n      other = _objectWithoutProperties(props, [\"tag\", \"key\", \"disabled\", \"onRemove\", \"classNameRemove\", \"getTagDisplayValue\"]);\n\n  return /*#__PURE__*/_jsxs(\"span\", _objectSpread(_objectSpread({}, other), {}, {\n    children: [getTagDisplayValue(tag), !disabled && /*#__PURE__*/_jsx(\"a\", {\n      className: classNameRemove,\n      onClick: e => onRemove(key)\n    })]\n  }), key);\n}\n\nfunction defaultRenderInput(_ref) {\n  let {\n    addTag\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"addTag\"]);\n\n  let {\n    onChange,\n    value\n  } = props,\n      other = _objectWithoutProperties(props, [\"onChange\", \"value\"]);\n\n  return /*#__PURE__*/_jsx(\"input\", _objectSpread({\n    type: \"text\",\n    onChange: onChange,\n    value: value\n  }, other));\n}\n\nfunction defaultRenderLayout(tagComponents, inputComponent) {\n  return /*#__PURE__*/_jsxs(\"span\", {\n    children: [tagComponents, inputComponent]\n  });\n}\n\nfunction defaultPasteSplit(data) {\n  return data.split(\" \").map(d => d.trim());\n}\n\nconst defaultInputProps = {\n  className: \"react-tagsinput-input\",\n  placeholder: \"Add a tag\"\n};\nconst TagsInput = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const divElementRef = React.useRef(null);\n  const inputElementRef = React.useRef(null);\n  const [tagState, setTagState] = React.useState(\"\");\n  const [isFocusedState, setIsFocusedState] = React.useState(false);\n  React.useEffect(() => {\n    if (hasControlledInputHook() && !inputValueHook(props)) {} else {\n      setTagState(inputValueHook(props));\n    }\n  }, [props]);\n\n  const {\n    value,\n    onChange,\n    tagProps,\n    renderLayout,\n    renderTag,\n    renderInput,\n    addKeys,\n    removeKeys,\n    className,\n    focusedClassName,\n    addOnBlur,\n    addOnPaste,\n    inputProps,\n    pasteSplit,\n    onlyUnique,\n    maxTags,\n    validate,\n    validationRegex,\n    disabled,\n    tagDisplayProp,\n    inputValue,\n    onChangeInput\n  } = props,\n        other = _objectWithoutProperties(props, [\"value\", \"onChange\", \"tagProps\", \"renderLayout\", \"renderTag\", \"renderInput\", \"addKeys\", \"removeKeys\", \"className\", \"focusedClassName\", \"addOnBlur\", \"addOnPaste\", \"inputProps\", \"pasteSplit\", \"onlyUnique\", \"maxTags\", \"validate\", \"validationRegex\", \"disabled\", \"tagDisplayProp\", \"inputValue\", \"onChangeInput\"]);\n\n  const _getTagDisplayValueHook = tagInner => {\n    if (tagDisplayProp) {\n      return tagInner[tagDisplayProp];\n    }\n\n    return tagInner;\n  };\n\n  const _makeTagHook = tagInner => {\n    if (tagDisplayProp) {\n      return {\n        [tagDisplayProp]: tagInner\n      };\n    }\n\n    return tagInner;\n  };\n\n  const _removeTagHook = indexInner => {\n    let valueInner = value.concat([]);\n\n    if (indexInner > -1 && indexInner < valueInner.length) {\n      let changed = valueInner.splice(indexInner, 1);\n      onChange(valueInner, changed, [indexInner]);\n    }\n  };\n\n  const _clearInputHook = () => {\n    if (hasControlledInputHook()) {\n      onChangeInput(\"\");\n    } else {\n      setTagState(\"\");\n    }\n  };\n\n  const _tagHook = () => {\n    if (hasControlledInputHook()) {\n      return inputValue;\n    }\n\n    return tagState;\n  };\n\n  const _addTagsHook = tagsInner => {\n    let {\n      onValidationReject\n    } = props;\n\n    if (onlyUnique) {\n      tagsInner = uniq(tagsInner);\n      tagsInner = tagsInner.filter(tag => value.every(currentTag => _getTagDisplayValueHook(currentTag) !== _getTagDisplayValueHook(tag)));\n    }\n\n    const rejectedTags = tagsInner.filter(tag => !_validateHook(_getTagDisplayValueHook(tag)));\n    tagsInner = tagsInner.filter(tag => _validateHook(_getTagDisplayValueHook(tag)));\n    tagsInner = tagsInner.filter(tag => {\n      let tagDisplayValueInner = _getTagDisplayValueHook(tag);\n\n      if (typeof tagDisplayValueInner.trim === \"function\") {\n        return tagDisplayValueInner.trim().length > 0;\n      } else {\n        return tagDisplayValueInner;\n      }\n    });\n\n    if (maxTags >= 0) {\n      let remainingLimitInner = Math.max(maxTags - value.length, 0);\n      tagsInner = tagsInner.slice(0, remainingLimitInner);\n    }\n\n    if (onValidationReject && rejectedTags.length > 0) {\n      onValidationReject(rejectedTags);\n    }\n\n    if (tagsInner.length > 0) {\n      let newValueInner = value.concat(tagsInner);\n      let indexesInner = [];\n\n      for (let i = 0; i < tagsInner.length; i++) {\n        indexesInner.push(value.length + i);\n      }\n\n      onChange(newValueInner, tagsInner, indexesInner);\n\n      _clearInputHook();\n\n      return true;\n    }\n\n    if (rejectedTags.length > 0) {\n      return false;\n    }\n\n    _clearInputHook();\n\n    return false;\n  };\n\n  const _validateHook = tagInner => {\n    return validate(tagInner) && validationRegex.test(tagInner);\n  };\n\n  const _shouldPreventDefaultEventOnAddHook = (addedInner, emptyInner, keyCodeInner) => {\n    if (addedInner) {\n      return true;\n    }\n\n    if (keyCodeInner === 13) {\n      return props.preventSubmit || !props.preventSubmit && !emptyInner;\n    }\n\n    return false;\n  };\n\n  const focusHook = () => {\n    if (inputElementRef.current && typeof inputElementRef.current.focus === \"function\") {\n      inputElementRef.current.focus();\n    }\n\n    handleOnFocusHook();\n  };\n\n  const blurHook = () => {\n    if (inputElementRef.current && typeof inputElementRef.current.blur === \"function\") {\n      inputElementRef.current.blur();\n    }\n\n    handleOnBlurHook();\n  };\n\n  const acceptHook = () => {\n    let tagInner = _tagHook();\n\n    if (tagInner !== \"\") {\n      tagInner = _makeTagHook(tagInner);\n      return _addTagsHook([tagInner]);\n    }\n\n    return false;\n  };\n\n  const addTagHook = tagInner => {\n    return _addTagsHook([tagInner]);\n  };\n\n  const clearInputHook = () => {\n    _clearInputHook();\n  };\n\n  const handlePasteHook = e => {\n    if (!addOnPaste) {\n      return;\n    }\n\n    e.preventDefault();\n    let dataInner = getClipboardData(e);\n    let tagsInner = pasteSplit(dataInner).map(tagInner => _makeTagHook(tagInner));\n\n    _addTagsHook(tagsInner);\n  };\n\n  const handleKeyDownHook = e => {\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    const tagInner = _tagHook();\n\n    let emptyInner = tagInner === \"\";\n    let keyCodeInner = e.keyCode;\n    let keyInner = e.key;\n    let addInner = addKeys.indexOf(keyCodeInner) !== -1 || addKeys.indexOf(keyInner) !== -1;\n    let removeInner = removeKeys.indexOf(keyCodeInner) !== -1 || removeKeys.indexOf(keyInner) !== -1;\n\n    if (addInner) {\n      let addedInner = acceptHook();\n\n      if (_shouldPreventDefaultEventOnAddHook(addedInner, emptyInner, keyCodeInner)) {\n        e.preventDefault();\n      }\n    }\n\n    if (removeInner && value.length > 0 && emptyInner) {\n      e.preventDefault();\n\n      _removeTagHook(value.length - 1);\n    }\n  };\n\n  const handleClickHook = e => {\n    if (e.target === divElementRef.current) {\n      focusHook();\n    }\n  };\n\n  const handleChangeHook = e => {\n    let {\n      onChange\n    } = props.inputProps;\n    let tagInner = e.target.value;\n\n    if (onChange) {\n      onChange(e);\n    }\n\n    if (hasControlledInputHook()) {\n      onChangeInput(tagInner);\n    } else {\n      setTagState(tagInner);\n    }\n  };\n\n  const handleOnFocusHook = e => {\n    let {\n      onFocus\n    } = props.inputProps;\n\n    if (onFocus) {\n      onFocus(e);\n    }\n\n    setIsFocusedState(true);\n  };\n\n  const handleOnBlurHook = e => {\n    let {\n      onBlur\n    } = props.inputProps;\n    setIsFocusedState(false);\n\n    if (e == null) {\n      return;\n    }\n\n    if (onBlur) {\n      onBlur(e);\n    }\n\n    if (addOnBlur) {\n      const tagInner = _makeTagHook(e.target.value);\n\n      _addTagsHook([tagInner]);\n    }\n  };\n\n  const handleRemoveHook = tagInner => {\n    _removeTagHook(tagInner);\n  };\n\n  const inputPropsHook = () => {\n    // eslint-disable-next-line\n    let _props$inputProps = props.inputProps,\n        {\n      onChange,\n      onFocus,\n      onBlur\n    } = _props$inputProps,\n        otherInputProps = _objectWithoutProperties(_props$inputProps, [\"onChange\", \"onFocus\", \"onBlur\"]);\n\n    let propsInner = _objectSpread(_objectSpread({}, defaultInputProps), otherInputProps);\n\n    if (disabled) {\n      propsInner.disabled = true;\n    }\n\n    return propsInner;\n  };\n\n  const inputValueHook = propsInner => {\n    return propsInner.currentValue || propsInner.inputValue || \"\";\n  };\n\n  const hasControlledInputHook = () => {\n    return typeof onChangeInput === \"function\" && typeof inputValue === \"string\";\n  };\n\n  let divClassName = className;\n\n  if (isFocusedState) {\n    divClassName = className + \" \" + focusedClassName;\n  }\n\n  let tagComponents = value.map((tag, index) => {\n    return renderTag(_objectSpread({\n      key: index,\n      tag,\n      onRemove: handleRemoveHook,\n      disabled,\n      getTagDisplayValue: _getTagDisplayValueHook\n    }, tagProps));\n  });\n  let inputComponent = renderInput(_objectSpread({\n    ref: inputElementRef,\n    value: _tagHook(),\n    onPaste: handlePasteHook,\n    onKeyDown: handleKeyDownHook,\n    onChange: handleChangeHook,\n    onFocus: handleOnFocusHook,\n    onBlur: handleOnBlurHook,\n    addTag: addTagHook\n  }, inputPropsHook()));\n  React.useImperativeHandle(ref, () => ({\n    _getDivElementRef: divElementRef.current,\n    _getInputElementRef: inputElementRef.current,\n    props: props,\n    _getTagState: tagState,\n    _getTagDisplayValue: tagInner => {\n      return _getTagDisplayValueHook(tagInner);\n    },\n    _makeTag: tagInner => {\n      return _makeTagHook(tagInner);\n    },\n    _removeTag: indexInner => {\n      _removeTagHook(indexInner);\n    },\n    _clearInput: () => {\n      _clearInputHook();\n    },\n    _tag: () => {\n      return _tagHook();\n    },\n    _addTags: tagsInner => {\n      return _addTagsHook(tagsInner);\n    },\n    _validate: tagInner => {\n      return _validateHook(tagInner);\n    },\n    _shouldPreventDefaultEventOnAdd: (addedInner, emptyInner, keyCodeInner) => {\n      return _shouldPreventDefaultEventOnAddHook(addedInner, emptyInner, keyCodeInner);\n    },\n    focus: () => {\n      focusHook();\n    },\n    blur: () => {\n      blurHook();\n    },\n    accept: () => {\n      return acceptHook();\n    },\n    addTag: tagInner => {\n      return addTagHook(tagInner);\n    },\n    clearInput: () => {\n      clearInputHook();\n    },\n    handlePaste: e => {\n      handlePasteHook(e);\n    },\n    handleKeyDown: e => {\n      handleKeyDownHook(e);\n    },\n    handleClick: e => {\n      handleClickHook(e);\n    },\n    handleChange: e => {\n      handleChangeHook(e);\n    },\n    handleOnFocus: e => {\n      handleOnFocusHook(e);\n    },\n    handleOnBlur: e => {\n      handleOnBlurHook(e);\n    },\n    handleRemove: tagInner => {\n      handleRemoveHook(tagInner);\n    },\n    inputProps: () => {\n      return inputPropsHook();\n    },\n    inputValue: propsInner => {\n      return inputValueHook(propsInner);\n    },\n    hasControlledInput: () => {\n      return hasControlledInputHook();\n    }\n  }));\n  return /*#__PURE__*/_jsx(\"div\", {\n    ref: divElementRef,\n    onClick: handleClickHook,\n    className: divClassName,\n    children: renderLayout(tagComponents, inputComponent)\n  });\n});\nTagsInput.defaultProps = {\n  className: \"react-tagsinput\",\n  focusedClassName: \"react-tagsinput--focused\",\n  addKeys: [9, 13],\n  addOnBlur: false,\n  addOnPaste: false,\n  inputProps: {},\n  removeKeys: [8],\n  renderInput: defaultRenderInput,\n  renderTag: defaultRenderTag,\n  renderLayout: defaultRenderLayout,\n  pasteSplit: defaultPasteSplit,\n  tagProps: {\n    className: \"react-tagsinput-tag\",\n    classNameRemove: \"react-tagsinput-remove\"\n  },\n  onlyUnique: false,\n  maxTags: -1,\n  validate: () => true,\n  validationRegex: /.*/,\n  disabled: false,\n  tagDisplayProp: null,\n  preventSubmit: true\n};\nexport default TagsInput;","map":null,"metadata":{},"sourceType":"module"}